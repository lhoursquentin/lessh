#! /bin/bash

usage()
{
  cat <<'EOF'
Usage: lessh [OPTION]... [input-file]

  -h, --help  display this help and exit

If no imput file is specified, then the standard input is read
EOF
  exit "$1"
}

leave() {
  tput cnorm
  tput rmcup
  tput rc
  exit
}

print_line() {
  printf '%s\n' "$output" | sed -n "$1"p
}

screen_nb_lines() {
  printf '%s\n' "$(($(tput lines) - 1))"
}

process_input() {
  index=1
  output=
  nb_lines=0
  while IFS= read -r line; do
    output="$output$line
"
    nb_lines="$((nb_lines + 1))"
    if [ "$nb_lines" -le "$(screen_nb_lines)" ]; then
      printf '%s\n' "$line"
    fi
  done
}

print_bar() {
  color="$1"
  shift
  tput cup "$(($(screen_nb_lines) + 1))" 0
  printf '%b%s' "$color" "$padding"
  tput cup "$(($(screen_nb_lines) + 1))" 0
  printf "$@"
}

print_status_bar() {
  print_bar '\e[48;5;8m' '%s%s' "${filename+File: $filename - }" 'Press q to quit'
  printf '\e[0m'
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help)
      usage 0
      shift
      ;;
    *)
      # TODO add multiple files support
      [ -n "$filename" ] && usage 1
      if [ ! -f "$1" ];then
        printf '%s: No such file or directory\n' "$1" >&2
        usage 1
      fi
      filename="$1"
      shift
      ;;
  esac
done

trap leave INT TERM

tput sc
tput smcup
tput civis

clear

if [ -n "$filename" ]; then
  process_input < "$filename"
else
  process_input
fi

padding="$(for i in $(seq "$(tput cols)"); do printf ' '; done; printf x)"
padding="${padding%?}"

print_status_bar

while read -n 1 -s key; do
  case "$key" in
    f)
      next_line_num="$((index + $(screen_nb_lines)))"
      if [ "$next_line_num" -le "$nb_lines" ]; then
        index="$((index + 1))"
        tput cup "$(screen_nb_lines)" 0
        tput el 1
        print_line "$next_line_num"
        print_status_bar
      fi
      ;;
    b)
      next_line_num="$((index - 1))"
      if [ "$next_line_num" -ge 1 ]; then
        index="$next_line_num"
        tput cup 0 0
        tput il 1
        print_line "$next_line_num"
        print_status_bar
      fi
      ;;
    q)
      leave
      ;;
    '>')
      print_bar '\e[1;44m' '> '
      tput cnorm
      IFS= read -r cmd
      printf '\e[0m'
      tput civis
      printf '%s\n' "$cmd" >> ~/.lessh_history
      output="$(printf '%s\n' "$output" | eval "$cmd")"
      lines="$(printf '%s\n' "$output" | wc -l)"
      clear
      print_line "1,$(screen_nb_lines)"
      print_status_bar
  esac
done < /dev/tty
