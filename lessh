#! /bin/bash

usage()
{
  cat <<'EOF'
Usage: lessh [OPTION]... [input-file]

  -h, --help  display this help and exit

If no imput file is specified, then the standard input is read
EOF
  exit "$1"
}

leave() {
  tput cnorm
  tput rmcup
  tput rc
  exit
}

print_line() {
  printf '%s\n' "$output" | sed -n "$1"p
}

# cache value?
screen_nb_lines() {
  printf '%s\n' "$(($(tput lines) - 1))"
}

process_input() {
  index=1
  output=
  nb_lines=0
  while IFS= read -r line; do
    output="$output$line
"
    nb_lines="$((nb_lines + 1))"
    if [ "$nb_lines" -le "$(screen_nb_lines)" ]; then
      printf '%s\n' "$line"
    fi
  done
}

print_bar() {
  color="$1"
  shift
  tput cup "$(($(screen_nb_lines) + 1))" 0
  printf '%b%s' "$color" "$padding"
  tput cup "$(($(screen_nb_lines) + 1))" 0
  printf "$@"
}

print_status_bar() {
  print_bar '\e[48;5;8m' '%s%s' "${filename+File: $filename - }" 'Press q to quit'
  printf '\e[0m'
}

scroll_up() {
  next_line_num="$((index - 1))"
  if [ "$next_line_num" -ge 1 ]; then
    index="$next_line_num"
    tput cup 0 0
    tput il 1
    print_line "$next_line_num"
    print_status_bar
  fi
}

scroll_down() {
  next_line_num="$((index + $(screen_nb_lines)))"
  if [ "$next_line_num" -le "$nb_lines" ]; then
    index="$((index + 1))"
    tput cup "$(screen_nb_lines)" 0
    tput el 1
    print_line "$next_line_num"
    print_status_bar
  fi
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help)
      usage 0
      shift
      ;;
    *)
      # TODO add multiple files support
      [ -n "$filename" ] && usage 1
      if [ ! -f "$1" ];then
        printf '%s: No such file or directory\n' "$1" >&2
        usage 1
      fi
      filename="$1"
      shift
      ;;
  esac
done

readonly stderr_file=/tmp/lessh_stderr

trap leave INT TERM

tput sc
tput smcup
tput civis

clear

if [ -n "$filename" ]; then
  process_input < "$filename"
else
  process_input
fi

padding="$(for i in $(seq "$(tput cols)"); do printf ' '; done; printf x)"
padding="${padding%?}"

print_status_bar

while read -n 1 -s key; do
  case "$key" in
    f)
      scroll_down
      ;;
    b)
      scroll_up
      ;;
    q)
      leave
      ;;
    ':')
      print_bar '\e[1;44m' "$key"
      tput cnorm
      enter=false
      if IFS= read -r cmd; then
        enter=true
        index="$((index + 1))"
      fi
      printf '\e[0m'
      tput civis
      if [ -n "$cmd" ] &&
         printf '%s\n' "$cmd" >> ~/.lessh_history &&
         {
           new_output="$(
             printf '%s\n' "$output" | eval "$cmd" 2> "$stderr_file"
           )"
           # FIXME print error on new screen or just notify failure
         }
      then
        output="$new_output"
        unset new_output
        lines="$(printf '%s\n' "$output" | wc -l)"
        clear
        print_line "1,$(screen_nb_lines)"
        print_status_bar
      else
        if "$enter"; then
          tput cup "$(screen_nb_lines)" 0
          tput el 1
          scroll_up
        else
          print_status_bar
        fi
      fi
  esac
done < /dev/tty
