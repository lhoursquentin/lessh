#! /bin/bash

usage()
{
  cat <<'EOF'
Usage: lessh [OPTION]... [input-file]

  -h, --help  display this help and exit

If no imput file is specified, then the standard input is read
EOF
  exit "$1"
}

leave() {
  tput cnorm
  tput rmcup
  tput rc
  exit
}

print_line() {
  printf '%s\n' "$output" | sed -n "$1"p
}

screen_nb_lines() {
  printf '%s\n' "$(($(tput lines) - 1))"
}

process_input() {
  output=
  nb_lines=0
  while IFS= read -r line; do
    output="$output$line
"
    nb_lines="$((nb_lines + 1))"
    if [ "$nb_lines" -le "$(screen_nb_lines)" ]; then
      printf '%s\n' "$line"
    fi
  done
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help)
      usage 0
      shift
      ;;
    *)
      # TODO add multiple files support
      [ -n "$filename" ] && usage 1
      if [ ! -f "$1" ];then
        printf '%s: No such file or directory\n' "$1" >&2
        usage 1
      fi
      filename="$1"
      shift
      ;;
  esac
done

trap leave INT TERM

tput sc
tput smcup
tput civis

clear

if [ -n "$filename" ]; then
  process_input < "$filename"
else
  process_input
fi

index=1
print_line 1,"$(screen_nb_lines)"

while read -n 1 -s key; do
  case "$key" in
    f)
      next_line_num="$((index + $(screen_nb_lines)))"
      if [ "$next_line_num" -le "$nb_lines" ]; then
        index="$((index + 1))"
        tput cup "$(screen_nb_lines)" 0
        print_line "$next_line_num"
      fi
      ;;
    b)
      next_line_num="$((index - 1))"
      if [ "$next_line_num" -ge 1 ]; then
        index="$next_line_num"
        tput cup 0 0
        tput il 1
        print_line "$next_line_num"
        tput cup "$(screen_nb_lines)" 0
        tput dl 1
      fi
      ;;
    q)
      leave
      ;;
    '>')
      tput cup "$(($(screen_nb_lines) + 1))" 0
      tput cnorm
      padding="$(for i in $(seq "$(tput cols)"); do printf ' '; done; printf x)"
      printf '\e[1;44m>%s' "${padding%????}"
      tput cup "$(($(screen_nb_lines) + 1))" 2
      IFS= read -r cmd
      printf '\e[0m'
      tput civis
      printf '%s\n' "$cmd" >> ~/.lessh_history
      printf '%s\n' "$output" | eval "$cmd" | { clear; process_input; }

  esac
done < /dev/tty
